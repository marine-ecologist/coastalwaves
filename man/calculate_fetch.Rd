% Generated by roxygen2: do not edit by hand
% Please edit documentation in r/calculate_fetch.R
\name{calculate_fetch}
\alias{calculate_fetch}
\title{Calculate Fetch Lengths from Points Using Radiating Bearings}
\usage{
calculate_fetch(
  points,
  degrees,
  fetch = 5000,
  land,
  parallel = TRUE,
  cores = 9
)
}
\arguments{
\item{points}{An \code{sf} object of type \code{POINT} with a column \code{id}.}

\item{degrees}{Numeric. Angular spacing between bearings (e.g., 7.5, 10).}

\item{fetch}{Numeric. Maximum fetch distance in meters. Default is 5000.}

\item{land}{An \code{sf} object representing land polygons (must overlap rays).}

\item{parallel}{Logical. If \code{TRUE}, uses \code{furrr::future_map_dfr} for parallel execution.}

\item{cores}{Integer. Number of cores to use if \code{parallel = TRUE}.}
}
\value{
An \code{sf} object with \code{id}, \code{bearing}, \code{segment_id}, \code{geometry}, and \code{length_km} columns.
}
\description{
This function generates rays from input points at specified angular intervals,
clips them to land polygons, and calculates the effective fetch length
(open-water distance) for each direction. Optionally runs in parallel.
}
\details{
\itemize{
\item Rays are generated at \code{degrees} intervals around the compass.
\item Rays are clipped by land polygons to estimate open-water fetch.
\item Fetch is measured as the remaining ray segment length after clipping land.
}
}
\examples{
\dontrun{
  future::plan(multisession, workers = 4)
  fetch_data <- calculate_fetch(my_points, degrees = 10, fetch = 5000, land = gbr_land, parallel = TRUE)
}

}
